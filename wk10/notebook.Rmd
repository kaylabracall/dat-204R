---
title: "R Markdown & ggplot"
author: "DAT-204 at CCAC"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

## R Markdown

R Markdown is how the R community seems to generally create notebooks. (Yes, I've been in Jupyter all semester. That appears to be less popular than creating a notebook in RStudio, and now I can kind of see why.)

Like a Jupyter notebook, an R Markdown file lets you combine text, code, and code outputs into a single document, which can be shared in several different formats.

### Getting started

Step one, to get going with R Markdown is to install the package. In your RStudio console, type

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
install.packages("rmarkdown")
library(rmarkdown)
```

Then you can go to your RStudio menu and create a new R Markdown file. Answering the questions that come up will generate what's known as YAML ("Yet Another Markup Language" - no, I'm not kidding) to go at the top of the file. 

Mine at one point looked like this:
```{R eval=FALSE, message=FALSE}
---
title: "R Markdown & ggplot"
author: "Coral Sheldon-Hess"
date: "November 4, 2020"
output: html_document
---
```

When you go to save it, you want to save in the format **.Rmd**

### Text

Your text bits will be in Markdown. Mostly, writing Markdown is a bit like writing notes in a text editor without WYSIWYG features, but we all occasionally need to look things up. [This is the cheat sheet I use](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet).

(Here we can pause and do some basic Markdown if anyone wants! I love Markdown and would be happy to do this, but I don't want to bore anyone.)

### Code chunks

A place where R Markdown differs from other Markdown is in how code chunks are dealt with. 

The easiest way to create a code chunk is to click "Insert" at the top of your .Rmd file in RStudio. To do it by hand, you'll type three back-ticks (the apostrophe-looking thing; it lives on the same key as the tilde on my keyboard), {R}, your code, and then three back-ticks:

` ```{R} `<br/>
` # code goes here `<br />
` ``` `

A cool thing about R Markdown is that it will accept languages other than R. Instead of R, above, you could use Python, SQL, Bash, JavaScript, CSS, or a couple of other languages. (Fun fact: YAML isn't one.)

```{python}
# check this out!
my_list = ["I", "love", "Python"]
print(" ".join(my_list) + "!")
```

Now, uh, to make that actually run, I needed a library named "reticulate" - I had to install the package and load the library. It also makes the whole notebook knit up more slowly. So maybe you're not going to do that every day, but it's a cool option to have.

#### Options for code chunks

You can apply options to a chunk:

* `include = FALSE`: run the code, but don't show it or its results in the final file

* `echo = FALSE`: run the code; don't show it in the final file; but its results can show

* `message = FALSE`: prevent any generated messages from showing

* `warning = FALSE`: prevent any generated errors from showing

* `eval = FALSE`: don't run the code

* `fig.cap = "some caption text"`: adds a caption to any figure that's generated by the block

The options go inside the curly braces in the declaration:

` ```{R eval=FALSE, include=FALSE} `

You can also apply options globally. Any given chunk has the ability to override global options, which is nice.

Here are the global options on this notebook (inside a chunk that isn't visible, at the top of this file):

` knitr::opts_chunk$set(echo = TRUE)`

## Rendering files

To make your HTML, .docx, .pdf, or other cool file out of your .Rmd file you'll want to render it. Most of us do this with the Knit button at the top of RStudio. (One of the steps in rendering is done by a tool called knitr, hence "knit")

But there's a command you can type in your console, if you prefer:
```{r eval=FALSE}
render("myNotebook.Rmd") # put in your actual filename there, and be in the right working directory
```

## ggplot

We've focused on `qplot()` so far this semester, because you can get pretty far with that, and it is (as the name suggests) fairly quick. But we get a few more options if we expand our horizons a little bit toward the full `ggplot()` functionality. 

ggplot really expects you to give it a dataframe, where qplot would make do with a vector; the keyword argument for this is `data = dataframe_name`. 

It also wants something called an "aesthetic," which you specify with the keyword `aes` - this is where your x and y variables are specified; the keyword argument for this is `mapping = aes()`

Now, ggplot is weird, because you can actually just call it with `ggplot()` and neither of its expected arguments; then, you can add them on later.

The thing is, you'll also want to specify a geometry (or more than one!) for your plot. Without providing an exhaustive list (which would be both long and overwhelming), here are a few you'll use a lot: `geom_point()`, `geom_bar()`, `geom_boxplot()` - and you might find that you want a different dataframe and/or a different aesthetic mapping for different geometries. 

Examples will help.

```{R}
library(ggplot2)

# mpg dataset; displ is engine displacement in liters,
# hwy is highway mileage
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point()
```

We could have done that several different ways:

```{R}
# mpg dataset; displ is engine displacement in liters,
# hwy is highway mileage
ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy))
```

```{R}
# you don't need the data or mapping keywords, really
ggplot(mpg, aes(x = displ, y = hwy)) + geom_point()
```

Adding color is fun. And sometimes illustrative.

```{R}
# looking at how vehicle class maps onto all of this
ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point()
```

The thing about geoms is that you can stack them, one on top of another:
```{R message=FALSE, warning=FALSE}
# looking at how vehicle class maps onto all of this
ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point() + geom_smooth()
# I suppressed them, but this threw a whole slew of errors, oops
```

Now, the way I have been typing this is not really how R programmers like to do things. This is more Rthonic, with the important note that **the plus sign has to go on the end of the line, not the beginning**:

```{R message=FALSE, warning=FALSE}
# looking at how vehicle class maps onto all of this
ggplot(mpg, aes(x = displ, y = hwy, color = class)) + 
  geom_point() + 
  geom_smooth()
```

Breaking these up by class all in one plot was neat, and adding the smoothed lines on top was ... also a thing. But what if we could break each class out into its own graph? That might tell us more.

To do that we will use `facet_wrap()`:

```{R }
# looking at how vehicle class maps onto all of this
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_wrap(~class, nrow = 2) 
  # the ugly tilda thing is called a "formula" in R
```

Now, as any good data visualizer can tell you, you have to label your axes. This is actually easier in ggplot than in qplot, I think; we use `labs(title="title", x="x label", y="y label")`:

```{R message=FALSE, warning=FALSE}
# looking at how vehicle class maps onto all of this
ggplot(mpg, aes(x = displ, y = hwy, color = class)) + 
  geom_point() + 
  labs(title="Highway Mileage of Vehicles by class and engine size", x="Engine displacement (liters)", y="Highway mpg")
```

This is starting to look good. It's worth noting that we can fiddle with the formatting of the labels using `theme()`:

```{R message=FALSE, warning=FALSE}
# looking at how vehicle class maps onto all of this
ggplot(mpg, aes(x = displ, y = hwy, color = class)) + 
  geom_point() + 
  labs(title="Mileage of Vehicles by engine size", 
       x="Engine displacement (liters)", 
       y="Highway mpg") +
  theme(plot.title=element_text(size=16, face="bold"),
        axis.text.x=element_text(size=10),
        axis.text.y=element_text(size=10),
        axis.title.x=element_text(size=12),
        axis.title.y=element_text(size=12))
```

I know we care very much about the label of our legend. As well we should! It's a tiny bit fiddly, but not super hard to handle. 

You have to know what you're separating on (we're using `color`, but you can use `shape` or `alpha` or a number of other attributes) and whether the variable you're separating on is continuous or discrete. And then it takes the form `scale_a_b(name="legend title")` where `a` is what you're separating on and `b` is either continuous or discrete. 

In our case, we're using color and class, which is a discrete variable, so we'll use `scale_color_discrete(name="Vehicle class")`:
```{R message=FALSE, warning=FALSE}
# looking at how vehicle class maps onto all of this
ggplot(mpg, aes(x = displ, y = hwy, color = class)) + 
  geom_point() + 
  labs(title="Mileage of Vehicles by engine size", 
       x="Engine displacement (liters)", 
       y="Highway mpg") +
  theme(plot.title=element_text(size=16, face="bold"),
        axis.text.x=element_text(size=10),
        axis.text.y=element_text(size=10),
        axis.title.x=element_text(size=12),
        axis.title.y=element_text(size=12)) +
  scale_color_discrete(name="Vehicle class")
```

Now, that was a bunch of scatterplots (and a couple of geom_smooth lines thrown in for flavor). But we need to know about histograms, too, don't we?

Like with qplot(), ggplot() can do counts for us automatically.

```{R message=FALSE, warning=FALSE}
# making a nice histogram of highway mileage
ggplot(mpg, aes(x = hwy)) + 
  geom_histogram()
```

And we've got some options, here. We can specify a binwidth, for instance, and we can fill with colors (which may or may not be all that helpful - I added "color='black'" to make it a little easier to see the classes):

```{R message=FALSE, warning=FALSE}
# making a nice histogram of highway mileage, but fatter
ggplot(mpg, aes(x = hwy, fill=class)) + 
  geom_histogram(binwidth = 5, color="black")
```

A really useful thing to do is to add a line for the mean with geom_vline -- also note that you can apply a color and fill to the entire histogram by adding attributes **outside** the aes() mapping:

```{R message=FALSE, warning=FALSE}
# making a nice histogram of highway mileage
ggplot(mpg, aes(x = hwy)) + 
  geom_histogram(color="black", fill="lightgreen") +
  geom_vline(aes(xintercept=mean(hwy)), linetype="dashed")
```

This is kind of what I had planned to cover. I have no idea how long any of it will take&mdash;it depends a bit how much fiddling around we do with things, I'm sure. But at this point, I think it might be fun (and illustrative) to throw together some graphs with another dataset. Yes?